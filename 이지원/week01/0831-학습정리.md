```
💡 1, 2 챕터는 스터디 전에 수강해서 내용을 채우지 않았습니다.
```
# Cocoa Touch

- 코코아: Objective-C 런타임 기반, NSObject를 상속받는 모든 클래스 또는 객체를 가리킬 때 사용
- 코코아 터치 또는 코코아: iOS 또는 macOS의 전반적인 기능을 활용해 애플리케이션을 제작할 때 사용하는 프레임워크 계층
- 코코아 터치: 핵심 프레임워크인 UIKit와 Foundation을 포함

# UIKit

iOS 애플리케이션의 사용자 인터페이스를 구현하고 이벤트를 관리하는 프레임워크

- 사용자 이벤트 처리를 위한 클래스 포함
- 화면 구성 요소 포함
- UIKit 클래스 중 UIResponder에서 파생된 클래스나 사용자 인터페이스에 관련된 클래스는 메인 스레드(혹은 메인 디스패치 큐)에서만 사용하기
- iOS와 tvOS 플랫폼에서 사용

## 생각해보기

새롭게 ViewController를 생성하면 상단에 'import UIKit'이 기본적으로 명시되어있는걸 본적 있나요?
왜 ViewController와 UIKit는 단짝일까요?

ViewController는 UIViewController를 상속받고 있다. UIViewController는 UIKit 프레임워크에 포함되어 있는 클래스이기 때문에 import를 해주어야 한다.

# Foundation

원시 데이터 타입(String, Int, Double), 컬렉션 타입(Array, Dictionary, Set) 및 운영체제 서비스를 사용해 애플리케이션의 기본적인 기능을 관리하는 프레임워크

- 데이터 타입, 날짜 및 시간 계산, 필터 및 정렬, 네트워킹 등의 기본 기능 제공
- 정의한 클래스, 프로토콜 및 데이터 타입은 iOS뿐만 아니라 macOS, watchOS, tvOS 등 모든 애플 SDK에서 사용됨

# Auto Layout

- 뷰의 제약 사항을 바탕으로 뷰 체계 내의 모든 뷰의 크기와 위치를 동적으로 계산
- 외부 변경과 내부 변경에 동적으로 반응하는 사용자 인터페이스를 가능하게 함

## 외부 변경(External Changes)

- 슈퍼뷰의 크기나 모양이 변경될 때 발생
- 외부 변경이 발생하는 경우
    - 사용자가 아이패드의 분할뷰(Split View)를 사용하거나 사용하지 않는 경우(iOS)
    - 장치를 회전하는 경우(iOS)
    - 활성화콜(active call)과 오디오 녹음 바가 보여지거나 사라지는 경우(iOS)
    - 다른 크기의 클래스를 지원하기 원하는 경우
    - 다른 크기의 스크린을 지원하기 원하는 경우

## 내부 변경(Internal Changes)

- 사용자 인터페이스의 뷰의 크기 또는 설정이 변경되었을 때 발생
- 내부 변경이 발생하는 경우
    - 애플리케이션 변경에 의해 콘텐츠가 보여지는 경우
    - 애플리케이션이 국제화를 지원하는 경우
    - 애플리케이션이 동적 타입을 지원하는 경우

## 오토 레이아웃이 필요한 경우

- 스크린 화면의 크기가 다양한 경우
- 스크린이 회전할 수 있는 경우
- 상태표시줄(Status Bar)에 전화 중임을 나타내는 액티브 콜(active call)과 오디오 녹음 중임을 나타내는 오디오 바가 보여지거나 사라지는 경우
    ```
    ❓ 이 경우는 아이폰XR 기준으로 시간 표시 부분이 빨간색으로 채워지는데 (시스템 내에서 동작하는 거 같음) 개발자가 고려해야하는 경우인지 모르겠음.
    ```
- 애플리케이션의 컨텐츠가 동적으로 보여지는 경우
- 애플리케이션이 지역화를 지원하는 경우
- 애플리케이션이 동적 타입을 지원하는 경우

# 프로그래밍 디자인 패턴

특정한 상황에서 일반적 설계문제를 해결하기 위해 상호교류하는 수정 가능한 객체와 클래스들에 대한 설명

소프트웨어를 설계할 때 특정 상황에서 자주 사용하는 패턴을 정형화한 것

## 특징

- 경험을 통해 얻을 수 있음
- 특정한 형식을 갖고 체계적으로 작성됨
- 패턴에는 각기 다른 추상화 수준이 존재, 계속 진화

## 장점

- 의사소통에 도움을 줌
- 검증된 지식인 패턴 사용 → 빠른 시간 내에 높은 완성도의 디자인 → 개발 비용 감소(경제적)
- 소프트웨어 구조 파악이 용이함, 소프트웨어 재사용성

## 분류

- 목적
패턴이 무엇을 하는지 정의하는 것. 생성, 구조, 행위 중의 한 가지 목적을 가짐
    - 생성 (Creational Pattern): 객체의 생성 과정에 관여하는 패턴
    - 구조 (Structural Pattern): 클래스나 객체의 구성을 통해 더 큰 구조로 만들 수 있게 해주는 것과 관련된 패턴
    - 행위 (Behavioral Pattern): 패턴을 주로 클래스에 적용하는지 아니면 객체에 적용하는지에 따라 구분되는 패턴
- 범위
패턴을 클래스에 적용하는지 아니면 객체에 적용하는지에 따라 구분되는 패턴
    - 클래스 패턴 (Class Pattern): 클래스들과 하위 클래스 간의 관계를 다루는 패턴. 컴파일 시에 관계가 결정됨
    - 객체 패턴 (Object Patterns): 객체 간의 관계를 다루며 보통 구성을 통해 정의. 일반적으로 실행시간에 관계가 생성 → 동적이면서 유연함

## 종류

- 싱글턴 패턴 (Singleton Pattern)
목적: 생성
범위: 객체
객체의 생성에 관련된 패턴, 특정 클래스의 인스턴스가 오직 하나임을 보장, 이 인스턴스에 접근할 방법을 제공

    ```swift
    class Person {
    	static let shared = Person()
    	private init() {}
    	
    	func eat() {
    		...
    	}
    }

    Person.shared.eat()
    ```

- 퍼사드 패턴 (Facade Pattern)
목적: 구조
범위: 객체
개발자가 사용해야 하는 서브 시스템의 가장 앞쪽에 위치, 하위 시스템에 있는 객체들을 사용할 수 있도록 하는 역할. 서브 시스템으로의 접근을 하나의 퍼사드 객체로 제공하는 패턴
- 옵저버 패턴 (Observer Pattern)
목적: 행위
범위: 객체
객체의 상태변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 패턴

    [NotificationCenter](https://developer.apple.com/documentation/foundation/notificationcenter) 참조

- 스트래티지 패턴 (Strategy Pattern)
목적: 행위
범위: 객체
알고리즘을 담당하는 각각의 클래스를 만들어 책임을 분산하기 위한 목적으로 만든 행위 패턴
- 팩토리 패턴 (Factory Pattern)
목적: 생성
범위: 클래스
객체를 생성하기 위한 인터페이스를 정의하지만 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 하위 클래스에서 이루어지도록 인스턴스 생성의 책임을 떠넘기는 패턴
- 어댑터 패턴 (Adapter Pattern)
목적: 구조
범위: 클래스, 객체
클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴. 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 동작하도록 해줌

# MVC 패턴(Model-View-Controller)

## 모델(Model)

- 애플리케이션과 관련된 데이터를 캡슐화, 해당 데이터를 조작, 처리하는 로직과 계산을 정의
- 데이터를 사용자에게 제공하거나 사용자가 이를 편집할 수 있는 뷰 객체에 명시적으로 연결되면 안됨

### 클래스 디자인 고려사항

- 인스턴스 변수
애플리케이션 내에 캡슐화된 데이터를 유지하기 위한 인스턴스 변수 선언. 인스턴스 변수는 객체, 스칼라 값, 또는 NSRange와 같은 구조체일 수 있음. 비객체형 대신 객체형을 사용하는 데에는 장단점이 있으므로, 객체 상호 관계를 고려해야 함
- 접근자 메서드와 프로퍼티
일반적으로 인스턴스 변수 값을 획득 및 설정하며, 흔히 획득자 및 설정자 메서드(getter and setter method)라고도 알려져있음. 스위프트의 경우, 인스턴스 변수를 private 또는 fileprivate 등으로 접근을 제어한 경우, 인스턴스 외부에서(fileprivate의 경우는 다른 소스파일에서) 접근하려면 접근자 메서드가 필요함
- 키-값(Key-value) 코딩
클라이언트가 프로퍼티 이름을 키로 사용하여 객체의 프로퍼티에 접근할 수 있게 하는 매커니즘. Core Data에서 사용하고 있으며 Cocoa의 다른 곳에서도 사용하고 있음. 접근자 메서드의 이름 지정(또한, 암시적으로 선언된 프로퍼티의 이름 지정)이 이 매커니즘의 요소가 됨.
- 초기화 및 할당 해제
인스턴스 변수를 적절한 초기값으로 설정하는 이니셜라이저 메서드 구현. 여기서 초기화는 이니셜라이저 메서드의 표준 형식을 따라야 하며, deinit 메서드에서는 객체 값을 가지는 모든 인스턴스 변수를 해제해야 함
- 객체 인코딩
객체를 보관하려는 경우, 해당 객체의 인스턴스 변수를 인코딩 및 디코딩할 수 있어야 함
- 객체 복제
클라이언트가 모델 객체를 복제할 것으로 예상하는 경우, 클래스에서 객체 복제를 구현해야 함

## 뷰(View)

- 애플리케이션 내에서 사용자가 볼 수 있는 객체
- 자신이 보이는 방법을 알고 있고 사용자 동작에 응답할 수 있음
- 애플리케이션의 모델 객체의 데이터를 보여주고 해당 데이터를 편집할 수 있도록 함

## 컨트롤러(Controller)

- 하나 이상의 애플리케이션 뷰 객체와 하나 이상의 모델 객체 사이의 코디네이터 또는 중개자 역할
- 뷰 객체에서 이루어진 사용자 동작 및 의도를 해석, 신규 혹은 변경된 데이터를 모델 객체에 전달
- 뷰 객체로 하여금 모델 객체의 변경사항을 인지하거나, 그 반대의 경우가 가능하도록 하는 매개체
- 애플리케이션의 설정 및 조정 작업 수행
- 다른 객체들의 생애주기(life cycle) 관리
- iOS 환경의 Cocoa Touch 프레임워크는 코디네이팅 컨트롤러, 뷰 컨트롤러의 두 가지 기본 컨트롤러 유형 제공

### 코디네이팅 컨트롤러(Coordinating Controllers)

- 애플리케이션 전체 혹은 일부 기능을 감독, 관리
- 애플리케이션별로 다른 로직이 각 애플리케이션에 주입(injected)되는 장소
    - 델리게이션(delegation) 메시지에 응답하고 알림(notifications)을 관리
    - 사용자가 버튼과 같은 컨트롤을 탭 하거나 클릭함에 따라 전송되는 동작 메시지(action message)에 응답
    - 객체 간의 연결을 확립하거나 기타 설정 작업 수행 (예: 애플리케이션을 시작하는 경우)
    - 소유한(owned) 객체의 생명 주기 관리
- iOS 애플리케이션에서는 뷰 컨트롤러가 코디네이팅 컨트롤러의 역할을 겸하는 경우가 많음

### 뷰 컨트롤러(View Controller)

- UiKit에서 뷰 컨트롤러는 컨텐츠를 화면에 표시하는 뷰를 관리, 해당 뷰에 대한 참조 유지, 뷰 컨트롤러는 이 뷰의 프레젠테이션(presentation) 및 후속 뷰로의 전환(transition)을 관리
- 모든 프레젠테이션 동작 뷰 컨트롤러 객체에 의해 관리되고 구현됨
- 모달뷰를 표시하고 메모리 부족 경고에 응답하며 기기의 방향(orientation)이 바뀔 때 뷰를 회전시킴
- iOS의 뷰 컨트롤러는 UIViewController 서브클래스의 인스턴스
- UiKit은 UITableViewController와 같은, UIViewController의 여러 특수 목적 서브클래스를 제공
- 컨트롤러가 모델과 뷰 간에 데이터를 중개하도록 반드시 프레임워크의 뷰-컨트롤러 클래스(예 : UIViewController, UITableViewController 등)를 확장해야 함.
- 뷰 컨트롤러는 여러 가지 프레임워크 객체에 대한 델리게이트 혹은 데이터 소스 객체인 경우가 많음