# 200902 Study Log

## Stanford iOS Swift
### Summary
* 카드 맞추기 게임 MVC 패턴으로 수정
* Swift 문법- 구조체, 클래스, static, lazy
* <b>Assignment: 카드 셔플하기</b>

#### MVC
* Model: 앱이 무슨 일을 하는지
* View: 컨트롤러의 미니언즈들; 화면 구성객체들
* Controller: 화면에 어떻게 나오는지

<b>MVC 패턴에서 중요한 점</b>
* 각각의 오브젝트(M,V,C)들이 어떻게 상호작용 하는지
  * 모델은 UI와 독립적
  * 컨트롤러와 뷰는 각각 UI의 부분집합
  * 뷰와 모델은 결코 상호작용 불가
  * 컨트롤러가 뷰와 모델 사이에서 열심히 일함
  * (그림)
    - 뷰와 컨트롤러는 target-action으로 구조적으로 대화
    - 컨트롤러는 타겟을 만들고 뷰는 액션을 가지고 타겟을 호출
    Q> target이 엄밀히 의미하는 바 더 자세히 공부하기
    - 모델과 컨트롤러는 notification, KVO; 즉 브로드캐스트로 통신

* MVC는 스크린 하나에 할당됨. 스크린이 여러 개가 될 수는 있어도 스크린 하나에 MVC가 여러 개가 될 수는 없음
  * 즉, 한 프로그램에 여러 개의 MVC가 존재할 수 있으므로 MVC끼리는 각각 다른 MVC를 자신의 뷰로 생각하여 소통
* 뷰는 단순한 객체임. 사용자와의 상호작용을 컨트롤러에 전달할 수는 있지만 어떻게 커뮤니케이션하고, 어떤 식으로 컨트롤되는지 알 수 없음.
그리고 뷰는 화면에 표시하는 데이터를 가지고 있지 않음
ex) 스크롤뷰

#### struct, class
가장 큰 차이점 2가지만 기억하고 갑시다
1. 구조체는 상속성이 없음 -> 더 간단
2. 구조체는 값 타입(복사됨), 클래스는 참조 타입(자료형 포인터)
복사: 모든 걸 다 복사하지 않고 누군가 값을 바꿨을 때 복사
Q>복사됨에 관련해서 이전에 공부했던 얕은 복사, 깊은 복사 추가적으로 공부하기

<b>추가로 알게 된 다른 점: init</b>
class와 struct 모두 init을 선언하지 않았을 때 constructor가 자동 생성된다.
그러나 class와 다르게 struct의 init은 이미 초기화된 변수가 있어도 모든 변수를 새로 다 받아서 초기화한다. 즉, 객체 생성시 모든 변수를 다 초기화해야 함.
```
struct TestInit{
  var initted : Int = 0
  var noInit : Int
}

// 다른 클래스에서 TestInit 객체 생성시
...
let test = TestInit(initted: 0, noInit: 1)
// initted는 이미 0으로 초기화했지만 자동생성 constructor에서는 새로 인자를 받아서 초기화함
```

#### 새로 알게 된 내용
* Static
항상 스태틱 의미를 제대로 알지 못하고 썼었는데 오늘 예제 통해서 좀 확실히 알게 된 듯. 내가 이해한 바가 맞는지는 더 확인해봐야겠지만
스태틱은 타입에 붙어있음을 알려주는 예약어
즉, 생성하는 객체가 아니라 해당 구조체나 클래스 자체에 붙어있기 때문에 .(dot) 연산자를 통해 타입에서 바로 사용 가능
따라서 클래스 안에 정적 메소드/변수가 있을 경우 해당 메소드/변수 앞에는 self.를 쓰지 않는다. 내가 만든 특정 객체에 붙어있는 놈이 아니고 이 타입 자체에 붙어있는 놈이기 때문에!
Q> 애매하게 알고 있어서 설명하라고하면 하기 애매한 self, this 의미 추가 공부
그리고 당연할 수도 있지만 같은 타입 안의 static끼리는 typeName. 없이 바로 사용 가능(같은 타입 안에 붙어있기 때문)

* lazy
완전 처음 들어본다.
예전에 Swift로 코딩할때 매번 클래스 안에 변수를 의존성 없이 다 초기화해주느라 쓸데없는 시간과 코드를 썼었는데, 이런 방법이 있었다.
즉, initializing은 엄밀히 말해서 self, 객체가 생성되기 전에 진행되어야 한다. 그런데 초기화할 값이 다른 인스턴스 변수에 의존성이 있다면? lazy를 사용한다.
lazy는 사용자가 해당 변수를(메소드도 되나? 될 것 같은데) 사용하기 전까지 초기화가 되지 않도록 해 준다. 즉, 객체 생성시에는 초기화 됐다고 봐주고, 사용하는 순간 초기화를 해 주는 역할을 한다.
그러나 lazy에도 제약 사항이 있는데, didSet을 사용하지 못한다는 것.
didSet이라는 것 자체가 setter 전후에 호출되는 건데 lazy는 사용할 때 초기화되는 거라 사용하지 못하는 건가?
Q> 추가공부하기!


* 배열 indices
매번 0..<array.count 할 필요가 없었다.
배열의 인덱스 값들을 시퀀스 형태로 반환해줌

* if문에서 여러 개 조건 사용 가능
매번
```
if A{
  if B{
  }
}
```
형태로 쓰느라 코드도 길어지고 지저분했는데 이런 방법이..
```
if A, B{  
}
```
가능 ^^
